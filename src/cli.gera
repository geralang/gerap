
mod gerap::cli

use gerap::log
use gerap::pkg
use gerap::make
use gerap::files
use gerap::docs
use gerap::config::CONFIG

use std::coll::Vector
use std::prc::Process
use std::env::(args, run)
use std::arr::(iter, collect)
use std::res::(unwrap_or_else, expect)
use std::opt::*
use std::str::*
use std::iter::*
use std::io::*

val USAGE = "Usage:
    gerap new <name> 
        -> create a new package in a new directory
    gerap init
        -> create a new package in this directory
    gerap build
        -> build the project in this directory
    gerap run
        -> run the project in this directory
    gerap test
        -> runs all tests for this package using the C target
    gerap info <thing>
        -> print information about a constant, procedure or module
    gerap doc <modules...>
        -> generate documentation for all given module names
    gerap clean
        -> delete all files generated by gerap"

val TESTS_FILE_TEMPLATE = "
mod gerap::testing

proc start() {
    case std::env::args()[1] {_
    }
}
"

proc main() {
    gerap::config::load()
    val args = args()
    case length(args) <= 1 -> {
        println(USAGE)
        return unit
    }
    case args[1] {
        "new" -> {
            case length(args) <= 2
                -> log::error("Missing name of new package!")
            val name = args[2]
            create_dir(name)
            files::init_package(name, name)
        }
        "init" -> {
            val name = get_cwd() 
                |> split(file_sep()) 
                |> last() |> expect("'split' returns at least 1 element")
            files::init_package(".", name)
        }
        "build" -> {
            val p = pkg::read_config("gerap.json")
            val release = length(args) >= 3 && args[2] == "release"
            make::build(p, Vector::new(), release)
        }
        "run" -> {
            val p = pkg::read_config("gerap.json")
            make::build(p, Vector::new(), false)
            case p.targ {
                "c" -> ".gerap/"
                    |> concat(p.name)
                    |> run()
                "js" -> CONFIG.js_path
                    |> concat(" .gerap/")
                    |> concat(p.name)
                    |> run()
            }
        }
        "test" -> {
            val p = pkg::read_config("gerap.json")
            p.targ = "c"
            p.main = #some "gerap::testing::start"
            create_dir(".gerap")
            val test_names = p.tests
                .> iter()
                |> map(-> it 
                    |> json::get_string() 
                    |> unwrap_or_else(||
                        "'_' is not a valid test!" 
                            |> fmt([it |> json::as_str()])
                    )
                )
                |> std::arr::collect()
            val test_branches = 0..length(test_names) 
                |> map(|test_idx| "        \"" 
                    |> concat(as_str(test_idx))
                    |> concat("\" -> ")
                    |> concat(test_names[test_idx])
                    |> concat("()\n")
                )
                |> join("")
            TESTS_FILE_TEMPLATE
                |> fmt([test_branches])
                |> write_file(".gerap/tests.gera")
            val gera_sources = Vector::new()
            gera_sources .> push(".gerap/tests.gera")
            make::build(p, gera_sources, false)
            mut failed = 0
            mut passed = 0
            0..length(test_names) |> for_each(|test_idx| {
                val test_name = test_names[test_idx]
                val test = Process::new(
                    ".gerap/" |> concat(p.name), [as_str(test_idx)]
                )
                log::testing(test_name, || test .> is_done())
                case unwrap_or(test .> exit_code(), 1) != 0 -> {
                    log::test_failed(test_name)
                    test .> output() |> print()
                    test .> eoutput() |> eprint()
                    failed = failed + 1

                } else {
                    log::test_passed(test_name)
                    passed = passed + 1
                }
            })
            log::test_result(failed, passed)
        }
        "info" -> {
            case length(args) <= 2
                -> log::error("Missing the path of the thing to document!")
            val path = args[2]
            case !file_exists(".gerap/symbols.json") -> {
                val p = pkg::read_config("gerap.json")
                make::build(p, Vector::new(), false)
            }
            val symbols = ".gerap/symbols.json"
                |> read_file()
                |> expect("should exist!")
                |> json::from_str()
                |> unwrap_or_else(|e| 
                    log::error("Symbol file should be valid!")
                )
                |> json::get_object()
                |> unwrap_or_else(|| log::error("Symbol file should be valid!"))
            val found = symbols
                |> docs::find_symbol(path)
            case found {
                #some thing -> docs::print_info(thing)
                #none -> "\n'_' could not be found.\n"
                    |> fmt([path])
                    |> println()
            }
        }
        "doc" -> {
            val modules = args
                |> iter()
                |> skip(2)
                |> take_while(-> !starts_with(it, "--"))
                |> collect()
            case !file_exists(".gerap/symbols.json") -> {
                val p = pkg::read_config("gerap.json")
                make::build(p, Vector::new(), false)
            }
            val symbols = ".gerap/symbols.json"
                |> read_file()
                |> expect("should exist!")
                |> json::from_str()
                |> unwrap_or_else(|e| 
                    log::error("Symbol file should be valid!")
                )
                |> json::get_object()
                |> unwrap_or_else(|| log::error("Symbol file should be valid!"))
            create_dir(".gerap/docs")
            docs::document_submodules(
                symbols, #none unit, modules, ".gerap/docs"
            )
        }
        "clean" -> {
            files::nuke_dir(".gerap")
        }
    } else println(USAGE)
}